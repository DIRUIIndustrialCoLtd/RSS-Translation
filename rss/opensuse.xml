<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title> openSUSE 新闻</title><link/>https://news.opensuse.org<description> openSUSE 项目的最新消息</description><atom:link href="https://news.opensuse.org/feed.xml" rel="self" type="application/rss+xml"></atom:link><item><guid> https://news.opensuse.org/2024/01/19/podman-wasm-support/</guid><title>使用 Podman 运行 WebAssembly 工作负载</title><pubDate>Fri, 19 Jan 2024 14:00:00 +0000</pubDate><link/> https://news.opensuse.org/2024/01/19/podman-wasm-support/<author> admin@opensuse.org（亚历山大·维琴齐） </author><enclosure length="27172" type="image/png" url="https://news.opensuse.org/wp-content/uploads/2024/01/webassembly.png"></enclosure><description> WebAssembly（缩写为 Wasm）是一种可移植的二进制指令格式。它因其作为编译目标的可移植性而广受欢迎，该编译目标支持在 Web 上部署客户端和服务器应用程序。我们可以利用 Wasm 的可移植性，通过结合 crun 和...来与 Linux 容器一起运行 Wasm 工作负载。</description><content:encoded> &lt;p>;&lt;a href=&quot;https://web assembly.org/&quot;>;WebAssembly&lt;/a>;（缩写为 Wasm）是一种可移植的二进制指令格式。它作为编译目标的可移植性而广受欢迎，可以在网络上部署客户端和服务器应用程序。&lt;/p>; &lt;p>;我们可以利用 Wasm 的可移植性，通过组合 &lt;code class 来与 Linux 容器一起运行 Wasm 工作负载=&quot;language-plaintexthighlighter-rouge&quot;>;crun&lt;/code>; 和 &lt;a href=&quot;https://podman.io/&quot;>;Podman&lt;/a>;。 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;crun&lt;/code>; 支持使用 &lt;a href=&quot;https://wasmedge.org/&quot;>;WasmEdge&lt;/a>;、&lt;a href=&quot; 运行 Wasm 工作负载https://wasmtime.dev/&quot;>;Wasmtime&lt;/a>;，或 &lt;a href=&quot;https://wasmer.io/&quot;>;Wasmer&lt;/a>; 运行时。 Podman 默认为 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;runc&lt;/code>;、&lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;runc&lt;/code>; 和 &lt;code class=&quot;language-纯文本highlighter-rouge&quot;>;crun&lt;/code>;可以互换使用。&lt;/p>; &lt;p>;&lt;a href=&quot;https://wasmedge.org/&quot;>;WasmEdge&lt;/a>;是一个轻量级、高性能的，以及适用于云原生和边缘应用程序的可扩展 WebAssembly 运行时。 WasmEdge 最近已添加到 &lt;a href=&quot;https://get.opensuse.org/tumbleweed/&quot;>;openSUSE Tumbleweed&lt;/a>; 中，如果我们在 &lt;code 中启用实验性功能，这可以为容器上的 Wasm 工作负载提供支持class=&quot;language-plaintexthighlighter-rouge&quot;>;crun&lt;/code>;。&lt;/p>; &lt;p>;现在 openSUSE Tumbleweed 和 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;crun&lt;/code 中已经有了 WasmEdge >; 对 Wasm 工作负载的实验性支持，我们可以在 Podman 上运行 WebAssembly 工作负载。&lt;/p>; &lt;h2 id=&quot;preparing-our-environment&quot;>;准备我们的环境&lt;/h2>; &lt;p>;我们首先需要安装 &lt;code class=&quot; language-plaintexthighlighter-rouge&quot;>;crun&lt;/code>; 在 Podman 的默认 OCI 运行时中为 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;runc&lt;/code>;。&lt;/p>; &lt;div class=&quot;language -bashhighlighter-rouge&quot;>;&lt;div class=&quot;highlight&quot;>;&lt;pre class=&quot;highlight&quot;>;&lt;code>;zypper &lt;span class=&quot;k&quot;>;在 &lt;/span>;crun &lt;/code>;&lt;/pre>;&lt; /div>;&lt;/div>; &lt;p>;安装 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;crun&lt;/code>; 后，检查您是否有 Wasm 支持。&lt;/p>; &lt;div class=&quot;language-bash高亮-rouge&quot;>;&lt;div class=&quot;highlight&quot;>;&lt;pre class=&quot;highlight&quot;>;&lt;code>;&lt;span class=&quot;nv&quot;>;$ &lt;/span>;crun &lt;span class=&quot;nt&quot;>;-v&lt;/ span>; crun 版本 1.9 提交：a538ac4ea1ff319bcfe2bf81cb5c6f687e2dc9d3 rundir：/run/user/1000/crun 规范：1.0.0 +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +CRIU +LIBKRUN +WASM:wasmedge +YAJL &lt;/code>;&lt; /pre>;&lt;/div>;&lt;/div>; &lt;p>;在上面的输出中，我们可以看到 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;crun&lt;/code>; 支持 WasmEdge (&lt;code class=&quot;language -plaintexthighlighter-rouge&quot;>;+WASM:wasmedge&lt;/code>;)。&lt;/p>; &lt;h2 id=&quot;preparing-our-application&quot;>;准备我们的应用程序&lt;/h2>; &lt;p>;我们将创建一个简单的Rust 中的“Hello”应用程序。&lt;/p>; &lt;p>;首先，确保安装了 Rust 和 WasmEdge。&lt;/p>; &lt;div class=&quot;language-bashhighlighter-rouge&quot;>;&lt;div class=&quot;highlight&quot;>;&lt; pre class=&quot;highlight&quot;>;&lt;code>;zypper &lt;span class=&quot;k&quot;>;在 &lt;/span>;rust wasmedge &lt;/code>;&lt;/pre>;&lt;/div>;&lt;/div>; &lt;p>;现在让我们创建我们的“ Rust 中的“Hello”应用程序。&lt;/p>; &lt;div class=&quot;language-bashhighlighter-rouge&quot;>;&lt;div class=&quot;highlight&quot;>;&lt;pre class=&quot;highlight&quot;>;&lt;code>;&lt;span class=&quot;nv&quot;>; $ &lt;/span>;货物新你好 &lt;span class=&quot;nt&quot;>;--bin&lt;/span>; &lt;span class=&quot;nv&quot;>;$ &lt;/span>;&lt;span class=&quot;nb&quot;>;cd &lt;/span>;你好&lt;/code>;&lt;/pre>;&lt;/div>;&lt;/div>; &lt;p>;将 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;src/main.rs&lt;/code>; 中的消息更改为 &lt;code class= “language-plaintexthighlighter-rouge&quot;>;Hello WebAssembly！&lt;/code>; 或您想要的任何其他消息。&lt;/p>; &lt;p>;现在让我们编译我们的应用程序，但目标机器将是 Wasm。&lt;/p>; &lt;div class=&quot;language-bashhighlighter-rouge&quot;>;&lt;div class=&quot;highlight&quot;>;&lt;pre class=&quot;highlight&quot;>;&lt;code>;&lt;span class=&quot;nv&quot;>;$ &lt;/span>;货物构建&lt;span class=&quot; nt&quot;>;--target&lt;/span>; wasm32-wasi &lt;/code>;&lt;/pre>;&lt;/div>;&lt;/div>; &lt;p>;我们现在可以执行刚刚编译的二进制文件并检查它是否按预期工作。&lt; /p>; &lt;div class=&quot;language-bashhighlighter-rouge&quot;>;&lt;div class=&quot;highlight&quot;>;&lt;pre class=&quot;highlight&quot;>;&lt;code>;&lt;span class=&quot;nv&quot;>;$ &lt;/span>;wasmedge 运行target/wasm32-wasi/debug/hello.wasm 你好 WebAssembly！ &lt;/code>;&lt;/pre>;&lt;/div>;&lt;/div>; &lt;p>;您已成功构建 Wasm 应用程序。&lt;/p>; &lt;h2 id=&quot;creating-a-wasm-container&quot;>;创建 Wasm 容器&lt; /h2>; &lt;p>;有了我们的 Wasm 二进制文件，让我们将其添加到容器中。&lt;/p>; &lt;p>;创建一个名为 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;Containerfile&lt;/code>; 的文件，并添加以下内容：&lt;/p>; &lt;div class=&quot;language-Dockerfilehighlighter-rouge&quot;>;&lt;div class=&quot;highlight&quot;>;&lt;pre class=&quot;highlight&quot;>;&lt;code>;&lt;span class=&quot;k&quot;>;从&lt;/span>;&lt;span class=&quot;s&quot;>;草稿&lt;/span>; &lt;span class=&quot;k&quot;>;复制&lt;/span>;&lt;span class=&quot;s&quot;>; target/wasm32-wasi/debug/hello.wasm /&lt;/span>; &lt;span class=&quot;k&quot;>;CMD&lt;/span>;&lt;span class=&quot;s&quot;>; [&quot;/hello.wasm&quot;]&lt;/span>; &lt;/code>;&lt;/pre>;&lt;/div>; &lt;/div>; &lt;p>;让我们使用 Buildah 构建 Wasm 容器。&lt;/p>; &lt;div class=&quot;language-bashhighlighter-rouge&quot;>;&lt;div class=&quot;highlight&quot;>;&lt;pre class=&quot;highlight&quot;>;&lt;code >;&lt;span class=&quot;nv&quot;>;$ &lt;/span>;buildah 构建 &lt;span class=&quot;nt&quot;>;--platform&lt;/span>;&lt;span class=&quot;o&quot;>;=&lt;/span>;wasi/wasm &lt;span class =&quot;nt&quot;>;-t&lt;/span>; hello-wasm &lt;span class=&quot;nb&quot;>;.&lt;/span>; &lt;/code>;&lt;/pre>;&lt;/div>;&lt;/div>; &lt;p>;你应该有一个现在 Wasm 容器。&lt;/p>; &lt;h2 id=&quot;running-a-wasm-workload&quot;>;运行 Wasm 工作负载&lt;/h2>; &lt;p>;让我们使用 Podman 运行 Wasm 容器。&lt;/p>; &lt;div class= “语言bash荧光笔-rouge”>;&lt;div class=&quot;highlight&quot;>;&lt;pre class=&quot;highlight&quot;>;&lt;code>;&lt;span class=&quot;nv&quot;>;$ &lt;/span>;podman run &lt;span class=&quot;nt&quot; >;--rm&lt;/span>; hello-wasm 你好 WebAssembly！ &lt;/code>;&lt;/pre>;&lt;/div>;&lt;/div>; &lt;p>;太好了，我们有一个可以工作的 Wasm 容器。&lt;/p>; &lt;h2 id=&quot;conclusion&quot;>;结论&lt;/h2>; &lt;p>;WebAssembly 是这是一个相当新的主题，但它已经获得了很多关注，因为您可以重用您已经知道或使用的大部分内容，并轻松移植应用程序。&lt;/p>; &lt;p>;运行本机 Wasm 容器是这种格式如何可移植的另一个示例&lt;/p>; &lt;meta name=&quot;openSUSE、Tumbleweed、开发人员、WebAssembly、Wasm、WasmEdge、Podman、runc、crun、容器&quot; content=&quot;HTML、CSS、XML、JavaScript&quot; />;</content:encoded></item><item><guid> https://news.opensuse.org/2024/01/19/clarifying-misunderstandings-of-slowroll/</guid><title>澄清对慢滚的误解</title><pubDate>Fri, 19 Jan 2024 13:00:00 +0000</pubDate><link/> https://news.opensuse.org/2024/01/19/clarifying-misunderstandings-of-slowroll/<author> admin@opensuse.org（道格拉斯·德马约） </author><enclosure length="214828" type="image/png" url="https://news.opensuse.org/wp-content/uploads/2024/01/slowroll.png"></enclosure><description>用例调查的结果提供了一些有关人们如何看待 openSUSE Slowroll 的深刻信息。有些人认为它是 openSUSE Leap 的替代品，但最近有关 Leap 明确路线的消息应该有助于解释 Slowroll 有一条不同的道路。 Slowroll 是一个实验性发行版...</description><content:encoded> &lt;p>;&lt;a href=&quot;https://news.opensuse.org/2023/11/06/results-of-use-case-survey-published/&quot;>;用例调查&lt;/a>;的结果给出了一些关于人们如何看待 &lt;a href=&quot;https://en.opensuse.org/openSUSE:Slowroll&quot;>;openSUSE Slowroll&lt;/a>; 的深刻信息。&lt;/p>; &lt;p>;有些人将其视为 openSUSE Leap 的替代品，但最近有消息称&lt;a href=&quot;https://news.opensuse.org/2024/01/15/clear-course-is-set-for-os-leap/&quot;>;为 Leap 设置了明确的课程&lt;/a >; 应该有助于解释 Slowroll 有不同的路径。&lt;/p>; &lt;p>;Slowroll 是 2023 年推出的实验性发行版。它被设计为 &lt;a href=&quot;https://get.opensuse.org/ tumbleweed/&quot;>;openSUSE Tumbleweed&lt;/a>;，当时 openSUSE Leap 的未来尚不清楚。&lt;/p>; &lt;p>;与 Tumbleweed 相比，该发行版的主要特点是滚动发布速度较慢。&lt;/p>; &lt;p>;一些用户可能会发现 Tumbleweed 的快速更新与 openSUSE Leap 等传统稳定版本之间的平衡很有价值。毕竟，开源软件的目的和原则是促进软件自由，使用户可以出于任何目的自由地研究、修改和分发软件； Slowroll 正在执行上述所有操作。&lt;/p>; &lt;p>;Slowroll 大约每隔一个月就会集成一次重大更新，并持续提供错误修复和安全更新。&lt;/p>; &lt;p>;Slowroll 背后的想法是提供一个可以提高稳定性的发行版，同时又不会失去对基础包中新功能（例如内核、桌面环境和打包）的访问。这些较慢的更新周期允许在包含之前对软件包进行更广泛的测试和验证。 Slowroll 更像是一种跳过，而不是 Leap。&lt;/p>; &lt;p>;关于 Slowrolls 与 openSUSE Leap 的关系，需要注意的是 Slowroll 并不是 Leap 的替代品。相反，它为寻求更新软件的用户提供了一种替代方案，其速度比 Tumbleweed 慢，但比 Leap 快得多。这在 SUSE Linux Enterprise 发行版的未来分支过渡到 ALP（自适应 Linux 平台）的背景下尤其重要。 Slowroll 的开发源于 openSUSE 开发者之间关于 openSUSE Leap 发行版的未来的讨论，但与 Leap 版本没有其他关系。&lt;/p>; &lt;p>;Slowroll 仍然相当新，并且基于 openSUSE Tumbleweed 软件包。&lt; /p>; &lt;p>;虽然 Slowroll 是 openSUSE 系列的重要补充，但它迎合了选择速度稍慢的最新软件系统的用户。选择 Slowroll 这个名称是为了反映其较慢的更新周期，并在社区投票过程后保留。&lt;/p>; &lt;meta name=&quot;openSUSE, Slowroll, user, Open Source, Rolling Release, Tumbleweed, stable, family&quot; content =&quot;HTML、CSS、XML、JavaScript&quot; />;</content:encoded></item><item><guid> https://news.opensuse.org/2024/01/15/clear-course-is-set-for-os-leap/</guid><title> openSUSE Leap 的明确路线已定</title><pubDate>Mon, 15 Jan 2024 11:00:00 +0000</pubDate><link/> https://news.opensuse.org/2024/01/15/clear-course-is-set-for-os-leap/<author> admin@opensuse.org（Lubos Kocman 和 Douglas DeMaio） </author><enclosure length="304190" type="image/png" url="https://news.opensuse.org/wp-content/uploads/2024/01/leap.png"></enclosure><description> openSUSE 发布团队确认将会有 Leap 15 的继任者，这是数字上的飞跃。正如许多人热切期待今年 Leap 15.6 的到来一样，Leap 16 作为继任者的道路也在等待着。 openSUSE Leap 基于 SUSE 新的 Adaptable Linux Platform (ALP) 代码库...</description><content:encoded> &lt;p>;openSUSE 发布团队确认将有 Leap 15 的后继版本，这是数字上的飞跃。&lt;/p>; &lt;p>;正如许多人热切等待今年 Leap 15.6 的到来一样，Leap 16 作为后继者的道路等待着。 openSUSE Leap 16 基于 SUSE 新的 Adaptable Linux Platform (ALP) 代码库，将先进的企业服务器分发的优点与用户友好的维护和安全性结合起来，这是 Leap 系列的标志。&lt;/p>; &lt;p>;Leap 16旨在在 SUSE 开发的 ALP 和有效集成社区软件包的举措中出现的尖端和传统 Linux 操作系统之间取得平衡。&lt;/p>; &lt;p>;向 Leap 16 的过渡不仅仅是一个数字步骤-上升，但象征着技术和用户体验方面的重要进步。 openSUSE Leap 的未来基于 SUSE Adaptable Linux Platform 的创新概念。&lt;/p>; &lt;p>;Adaptable Linux Platform 为下一代 openSUSE Leap、Leap Micro 和 SUSE 解决方案提供支持。它使发行版更具适应性，更适合云原生工作负载，同时还能够处理快速的创新。&lt;/p>; &lt;p>;没有计划放弃 Leap 的经典（非不可变）选项；非不可变或不可变安装变体均可用于 Leap 15，并计划用于 Leap 16。这将仍然是人们部署 Leap 的首选方式。&lt;/p>; &lt;p>;鼓励每个人参与 Leap 的开发通过提供反馈、打包、测试、文档和任何其他方式来创建这些新平台。&lt;/p>; &lt;p>;Leap 将继续遵循 &lt;a href=&quot;https://en.opensuse.org/openSUSE:Factory_development_model&quot;>; openSUSE 工厂开发模型&lt;/a>;。&lt;/p>; &lt;p>;开发过程将涉及收集需求，包括来自社区研讨会的需求，以确保 Leap 16.0 满足用户不断变化的需求​​。 openSUSE 社区已经开始关注 Leap 16 的预期推出。&lt;/p>; &lt;p>;除了 Leap 16，&lt;a href=&quot;https://get.opensuse.org/leapmicro/&quot;>;Leap Micro&lt;/ a>; 6.0将接替Leap Micro 5系列。它基于 SUSE Linux Enterprise Micro 6.0，专注于容器化和虚拟化工作负载。&lt;/p>; &lt;p>;Leap 和 Leap Micro 都将为用户提供清晰的迁移路径和充足的升级时间。如果 Leap 16 延迟，发布团队可能会延长 Leap 15.6 的生命周期，或者作为最后的手段，发布 Leap 15.7 以确保足够的重叠。 Leap 16 将确保发布与 Leap 15 的生命周期结束之间没有间隙。&lt;/p>; &lt;p>;人们可以在项目的 &lt;a href=&quot;https://en.opensuse.html&quot; 上找到有关 Leap 16 的信息更新。 org/openSUSE:Roadmap&quot;>;路线图页面&lt;/a>;。发布团队将分享 Leap 16 开发何时开始以及如何通过&lt;a href=&quot;https://en.opensuse.org/openSUSE:Communication_channels&quot;>;官方 openSUSE 渠道&lt;/a>;参与。&lt;/p>; &lt;meta name=&quot;openSUSE、开发人员、系统管理员、用户、开源、后继者、路线图、Leap、开发人员、适应性 Linux 平台、ALP、Leap Micro&quot; content=&quot;HTML,CSS,XML,JavaScript&quot; />;</content:encoded></item><item><guid> https://news.opensuse.org/2024/01/12/conference-adds-business-focused-networking-event/</guid><title>会议增加了以业务为中心的社交活动</title><pubDate>Fri, 12 Jan 2024 09:00:00 +0000</pubDate><link/> https://news.opensuse.org/2024/01/12/conference-adds-business-focused-networking-event/<author> admin@opensuse.org（道格拉斯·德马约） </author><enclosure length="423390" type="image/png" url="https://news.opensuse.org/wp-content/uploads/2024/01/opfbiz.png"></enclosure><description> openSUSE 项目很高兴地宣布 Open 4 Business 网络活动，这是一项由 DORS/CLUC 组织发起的协作计划，定于 6 月 26 日下午 2 点至 6 点在德国纽伦堡弗兰肯校区举行。该活动将与 openSUSE Con​​ference 2024 (oSC24) 同期举行，...</description><content:encoded> &lt;p>;&lt;a href=&quot;https://www.opensuse.org/&quot;>;openSUSE 项目&lt;/a>;很高兴地宣布 Open 4 Business 网络活动，这是一项由 &lt;a href=&quot;https://www.opensuse.org/&quot;>;openSUSE 项目发起的协作计划://www.dorsluc.org/open-4-business/&quot;>;DORS/CLUC&lt;/a>; 组织，定于 6 月 26 日下午 2 点至 6 点在德国纽伦堡弗兰肯校区举行。&lt;/p>; &lt;p >;本次活动将与 &lt;a href=&quot;https://events.opensuse.org/&quot;>;openSUSE Con​​ference 2024&lt;/a>; (oSC24) 同期举行，致力于促进开源行业的联系&lt;/p>; &lt;p>;该活动旨在帮助建立一个商业环境，以帮助在开源道德和技术方面持有相似价值观的中小企业 (SME) 保持一致。 Open 4 Business 活动旨在充当连接开源爱好者的桥梁。此次活动将帮助商界人士有效参与和协作。&lt;/p>; &lt;p>;Open 4 Business 旨在实现的主要目标是：&lt;/p>; &lt;ul>; &lt;li>;强调商界与开源社区&lt;/li>; &lt;li>;提供一个实现可持续和开放业务的平台&lt;/li>; &lt;li>;促进与开源项目的业务合作&lt;/li>; &lt;li>;促进中小企业、自由职业者之间的网络和合作伙伴关系和企业&lt;/li>; &lt;/ul>; &lt;p>;对于任何渴望扩展业务网络、发现新项目并与专家同行交流的人来说，此次活动都是一个机会。该项目邀请您参加 Open 4 Business 活动。&lt;/p>; &lt;p>;openSUSE 项目谨向 DORS/CLUC 组织表示感谢，感谢他们在发起 #open4business 网络活动中所发挥的作用，并旨在帮助扩展将此商业网络活动与其他社区驱动的开源技术会议联系起来。&lt;/p>; &lt;p>;要参加，请发送电子邮件至 ddemaio@opensuse.org，主题为“open4business”，或在 4 小时 Open 4 Business 选择项下提交提案。 Open 4 Business 活动的演讲将于 6 月 26 日在 4 小时内举行，每位演讲者每次演讲的持续时间不超过 15 分钟。请注意，本次活动的会谈将在商业网络轨道下进行，与 6 月 27 日至 29 日举行的会议技术轨道不同。该活动将在 Katzwanger Str. 举行。 130，位于纽伦堡 SUSE 办事处旁边的底层。&lt;/p>; &lt;p>;提交 &lt;a href=&quot;https://events.opensuse.org/&quot;>;oSC24&lt;/a>; 提案的时间为开放至 4 月 15 日。会议将在 &lt;a href=&quot;https://z-bau.com/&quot;>;Z-Bau&lt;/a>; 举行，位于纽伦堡 SUSE 办事处的街道上。&lt;/ p>; &lt;meta name=&quot;openSUSE、Rancher、开发人员、系统管理员、用户、开源、导师、学员、Google 代码之夏、研讨会&quot; content=&quot;HTML,CSS,XML,JavaScript&quot; />;</content:encoded></item><item><guid> https://news.opensuse.org/2024/01/09/project-plans-workshop-for-gsoc-mentorship/</guid><title>项目将举办导师申请研讨会</title><pubDate>Tue, 09 Jan 2024 10:00:00 +0000</pubDate><link/> https://news.opensuse.org/2024/01/09/project-plans-workshop-for-gsoc-mentorship/<author> admin@opensuse.org（道格拉斯·德马约） </author><enclosure length="433011" type="image/png" url="https://news.opensuse.org/wp-content/uploads/2024/01/workshop.png"></enclosure><description> openSUSE 项目将于世界标准时间 1 月 16 日 15:30 在 meet.opensuse.org/meeting 上举办研讨会，重点讨论今年的 Google Summer of Code 申请和指导工作。 openSUSE 项目有着参与 GSoC 的悠久传统以及希望作为导师参与的社区成员...</description><content:encoded> &lt;p>;&lt;a href=&quot;https://www.opensuse.org/&quot;>;openSUSE 项目&lt;/a>;将于世界标准时间 1 月 16 日 15:30 在 &lt;a href=&quot;https:// meet.opensuse.org/meeting&quot;>;meet.opensuse.org/meeting&lt;/a>; 将重点关注今年的 &lt;a href=&quot;https://summerofcode.withgoogle.com/&quot;>;Google 编程之夏&lt;/a >; 申请和指导工作。&lt;/p>; &lt;p>;openSUSE 项目有着参与 GSoC 的悠久传统，想要作为导师参与的社区成员应该参加或更新他们想要在 &lt;a href=&quot;https 上列出的项目://101.opensuse.org/&quot;>;101.opensuse.org&lt;/a>;，在 openSUSE 的 &lt;a href=&quot;https://github.com/openSUSE/mentoring&quot;>;GitHub Mentoring&lt;/a>; 上提出问题>; 项目。&lt;/p>; &lt;p>;研讨会将在 &lt;a href=&quot;https://calendar.opensuse.org/teams/marketing/events/tuesday_weekly_meeting&quot;>;openSUSE 社区会议&lt;/a>;之后确定金额可以列出今年申请的项目，申请开放时间为 1 月 22 日至 2 月 6 日。&lt;/p>; &lt;p>;研讨会将为导师和想要参与指导的人员提供足够的时间来描述几个项目想法在管理员提交 GSoC 申请之前。&lt;/p>; &lt;p>;鼓励参与者在 &lt;a href=&quot;https://etherpad.opensuse.org/p/GSoC2024WS&quot;>; 研讨会之前创建一些项目构想的大纲活动的 etherpad&lt;/a>;。&lt;/p>; &lt;p>;参加过之前 Google 编程之夏计划的导师和管理员将参加研讨会。&lt;/p>; &lt;meta name=&quot;openSUSE、Rancher、开发人员、系统管理员、用户、开源、导师、受训者、Google 代码之夏、研讨会&quot; content=&quot;HTML,CSS,XML,JavaScript&quot; />;</content:encoded></item><item><guid> https://news.opensuse.org/2023/12/20/systemd-fde/</guid><title> Tumbleweed 和 MicroOS 中的 Systemd 引导和全磁盘加密</title><pubDate>Wed, 20 Dec 2023 15:00:00 +0000</pubDate><link/> https://news.opensuse.org/2023/12/20/systemd-fde/<author> admin@opensuse.org（阿尔贝托·普拉纳斯） </author><enclosure length="7899" type="image/png" url="https://news.opensuse.org/wp-content/uploads/2023/12/systemd-light.png"></enclosure><description> Tumbleweed 和 MicroOS 中的 Systemd-boot 和全磁盘加密 openSUSE Tumbleweed 和 MicroOS 现在提供一个使用 systemd-boot 作为引导加载程序的映像，并且也基于 systemd 进行全磁盘加密。加密设备的解锁可以通过传统密码、TPM2（加密设备...</description><content:encoded> &lt;h1 id=&quot;systemd-boot-and-full-disk-encryption-in-tumbleweed-and-microos&quot;>;Tumbleweed 和 MicroOS 中的 Systemd-boot 和全磁盘加密&lt;/h1>; &lt;p>;openSUSE Tumbleweed 和 MicroOS 现已支持提供使用 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;systemd-boot&lt;/code>; 作为引导加载程序的映像，并基于 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;systemd 进行全磁盘加密&lt;/code>;。加密设备的解锁可以通过传统密码来完成，TPM2（系统中已存在的加密设备）将附加如果系统运行状况良好，则为设备，或者用于验证令牌所有权的 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;FIDO2&lt;/code>; 密钥。&lt;/p>; &lt;p>;有很多在这里解释一下，但基本上这些变化都是为了将​​发行版转移到更安全的地方。一方面是使发行版的设计更加简单，另一方面它遵循其他发行版也符合的当前安全趋势。&lt;/p>; &lt;p>;所以，让我们从头开始......&lt;/ p>; &lt;h2 id=&quot;systemd-boot&quot;>;systemd-boot&lt;/h2>; &lt;p>;我们都知道并且喜欢 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;GRUB2&lt;/code>;。这是一个很好的引导加载程序。它又大、复杂、丰富、庞大，并且在开发方面往往进展缓慢。&lt;/p>; &lt;p>;此引导加载程序的 openSUSE 软件包包含 200 多个补丁。其中一些补丁已经存在了过去 5 年、6 年……10 年。这既表明了维护者的才华，也表明了上游贡献过程可能有多慢的问题。&lt;/p>; &lt;p>;&lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;GRUB2&lt; /code>; 支持所有相关系统，包括大型机、&lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;arm&lt;/code>; 或 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;powerpc&lt;/code>;。多种类型的文件系统，包括 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;btrfs&lt;/code>; 或 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;NTFS&lt;/code>;。它包含一个完整的网络堆栈、一个 USB 堆栈、一个终端，可以编写脚本……从某种意义上说，它本身几乎就是一个迷你操作系统。 rouge&quot;>;UEFI&lt;/code>; 出现于 18 年前，使得 GRUB2 提供的几乎所有功能在某种程度上变得多余。系统固件已经将大部分功能作为服务提供，可供操作系统、引导加载程序或任何其他用户提供的应用程序使用。当然 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;GRUB2&lt;/code>; 也支持 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;UEFI&lt;/code>;。&lt;/p>; &lt;p>;很快Linux 内核可以通过可附加到内核代码的存根来编译为 EFI 二进制文件。这意味着内核本身可以由固件直接启动，从而使引导加载程序在大多数情况下成为可选的。&lt;/p>; &lt;p>;随着时间的推移，新的、更简单的引导加载程序专注于 &lt;code class=&quot;language-出现纯文本highlighter-rouge&quot;>;UEFI&lt;/code>;，例如&lt;a href=&quot;https://cgit.freedesktop.org/gummiboot/&quot;>;&lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;gummiboot&lt;/code >;&lt;/a>;。后来这段代码被集成到 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;systemd&lt;/code>; 中，并重命名为 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;systemd-boot&lt;/code>;。&lt;/code>; p>; &lt;p>;代码非常简单。比 GRUB2 简单许多数量级。它基本上是一个非常小的 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;EFI&lt;/code>; 二进制文件，它显示一个包含不同引导加载程序条目的菜单（&lt;a href=&quot;https:// 中描述的文本文件） uapi-group.org/specations/specs/boot_loader_specification/&quot;>;引导加载程序规范&lt;/a>; 或简称 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;BLS&lt;/code>;），以及对 &lt; code class=&quot;language-plaintexthighlighter-rouge&quot;>;UEFI&lt;/code>; &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;LoadImage&lt;/code>; 函数将执行委托给选定的内核。&lt;/p>; &lt; p>;此引导加载程序还可以使用新的&lt;a href=&quot;https://uapi-group.org/specations/specs/unified_kernel_image/&quot;>;统一内核映像&lt;/a>; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;>;UKI&lt;/code>;)，这些文件将内核、命令行和 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;initrd&lt;/code>; 聚合在一个单元中。这些 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;UKI&lt;/code>; 对于基于图像的发行版来说非常方便，openSUSE 也计划支持它们。&lt;/p>; &lt;p>;提供 &lt;code class= openSUSE 长期以来一直希望将“language-plaintexthighlighter-rouge&quot;>;systemd-boot&lt;/code>; 作为 GRUB2 的替代品。 2023 年 8 月，工厂邮件列表上发布了&lt;a href=&quot;https://lists.opensuse.org/archives/list/factory@lists.opensuse.org/thread/4FNZ7HEPH6KQQ2JVFNPN7PXWHZZRU5H5/&quot;>;公告&lt;/a>;，内容涉及Tumbleweed 支持 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;systemd-boot&lt;/code>;。&lt;/p>; &lt;p>;该公告引用了 &lt;a href=&quot;https://en.opensuse.org/Systemd -boot&quot;>;wiki 条目&lt;/a>;，解释如何使用 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;GRUB2&lt;/code>; 将安装迁移到 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;手动启动 systemd。公告发布后不久，&lt;a href=&quot;https://github.com/yast/yast-bootloader/pull/686&quot;>;&lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;yast-bootloader&lt;/code>; 获得了&lt;/a>; 支持新安装。&lt;/p>; &lt;p>;支持其他引导加载程序需要付费。正如所争论的那样，代码库更小，错误更少，并且更容易推理。但是 UEFI 依赖项减少了支持的架构（x86-64 和 aarch64）的数量。通过为 GRUB2 提供另一个补丁来支持 BLS，可以大大缓解这个问题>; 条目，因此引导加载程序之后的分发架构可以独立于引导加载程序本身。好消息是该补丁已经存在，并且可能会添加到包中。&lt;/p>; &lt;p>;另一个问题是 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;systemd-boot&lt;/code>;不会说 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;btrfs&lt;/code>;。作为一个 EFI 二进制文件，它只能从 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;FAT32 文件系统读取文件。通过将内核和 initrd 移至 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;EFI&lt;/code>; 系统分区 (&lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;ESP&lt; /code>;)。&lt;/p>; &lt;p>;最后，还要考虑支持 Tumbleweed 中的快照和 MicroOS 中的事务。从引导加载程序中，用户应该能够选择从哪个快照引导，就像使用 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;GRUB2&lt;/code>; 时实际上可以做到的那样。这两个概念都是使用 btrfs 子卷实现的，并且只有内核、命令行、&lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>; 的子集initrd&lt;/code>; 组合对每个子卷都有效。&lt;/p>; &lt;p>;例如，假设我们的系统中有两个快照，每个快照都代表一个安装了两个内核的系统。所有快照中的这两个内核可能都不相同。也许其中一项升级用较新的版本替换了一个内核。我们需要一些工具来完成关联正确组合所需的簿记工作，从而成功引导到任何这些快照，并在这些限制下创建引导条目。&lt;/p>; &lt;p>;这个工具是 &lt;a href=&quot; https://github.com/openSUSE/sdbootutil&quot;>;&lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;sdbootutil&lt;/code>;&lt;/a>;。每次 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;snapper&lt;/code>; 创建或销毁快照时（例如，当系统更新时），它都会调用此工具来分析快照的内容，确保相应的内核安装在 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;ESP&lt;/code>; 中，这是一个有效的 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;initrd&lt;/code>;该内核存在（如果不存在，则会调用 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;mkinitrd&lt;/code>; 创建），并创建一个连接内核的引导条目，&lt;code class=&quot;language-纯文本highlighter-rouge&quot;>;initrd&lt;/code>; 和通过命令行的快照。它还负责其他细节，例如检查分区上的可用空间。&lt;/p>; &lt;p>;通常他的过程透明地工作，但最好记住我们可以通过以下方式强制进入干净状态：&lt;/p>; &lt;div class=&quot;language-plaintexthighlighter-rouge&quot;>;&lt;div class=&quot;highlight&quot;>;&lt;pre class=&quot;highlight&quot;>;&lt;code>;sdbootutil add-all-kernels sdbootutil remove-all-kernels &lt;/code>;&lt;/pre>; &lt;/div>;&lt;/div>; &lt;p>;以防万一，你知道......&lt;/p>; &lt;h2 id=&quot;full-disk-encryption&quot;>;全盘加密&lt;/h2>; &lt;p>;我们想要的另一个方面宣布支持基于 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;systemd&lt;/code>; 的全盘加密 (&lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;FDE&lt;/code>;)。 &lt;/p>; &lt;p>;&lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;FDE&lt;/code>; 并不是新事物。 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;GRUB2&lt;/code>; 很久以前就可以使用 &lt;code class=&quot;language -纯文本荧光笔-rouge&quot;>;cryptomount&lt;/code>; 命令。传统上，这将向用户请求密码两次：一次是在引导加载程序进行解锁时，另一次是在 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;initrd&lt;/code>; 稍后执行相同操作时。有多种方法可以避免第二个请求将密码注入到 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;initrd&lt;/code>; 中，或者，如果您使用的是 openSUSE 包，它会将密码透明地注入到 &lt; code class=&quot;language-plaintexthighlighter-rouge&quot;>;initrd&lt;/code>;。&lt;/p>; &lt;p>;最近 &lt;code class=&quot;language-plaintexthighlighter-rouge&quot;>;GRUB2&lt;/code>; 获得了两个新功能：部分支持 LUKS2 加密设备（使用 PBKDF2 作为密钥派生函数，而不是更多安全和推荐的&lt;code class =“语言 -  plaintext Highlighter-rouge”>; argon2ID &lt;/code>;）和一个可以将秘密存储在设备中的密钥保护机制/code>;。&lt;/p>; &lt;h2 id =“ tpm2”>; &lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>; &lt;/code>; &lt;/h2>; &lt;p>;解释&lt;code class =&#39;landaging-色都满足了。 &lt;code class =“语言 -  plaintext Highlighter-rouge”>; tpm2 &lt;/code>;如果系统处于健康状态，则将解锁秘密。&lt;/p>; &lt;p>;该术语是技术性的，并且与断言该系统处于&lt;strong>;已知&lt;/strong>;良好状态。换句话说，我们确定固件尚未被篡改，启动加载器是我们安装并尚未替换的固件，内核正是来自分布的固件，即内核命令行是我们期望的那个，并且我们使用的&lt;code class =“ language-plaintext Highlighter-rouge”>; initrd &lt;/code>;不包含我们无法控制的任何额外的二进制。&lt;/p>; &lt;p>;内部&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;具有一些寄存器，称为平台配置寄存器（&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;）。在&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;规范中，有24个，一个大小足以存储哈希函数的值，例如&lt;code class =“ language-class-” Plaintext Highlighter-Rouge“>; sha1 &lt;/code>;或&lt;code class =“ language-plaintext Highlighter-rouge”>; sha256 &lt;/code>;。它们被银行分开：每个受支持的哈希功能，但这暂时太多了。&lt;/p>; &lt;p>;这些寄存器很特别。我们可以将它们重置，通常将值设置为0。我们可以读取值，也可以“扩展”它们。写操作的设计方式是我们无法在寄存器中设置任何随机值，但相关的哈希函数的结果与当前&lt;code class =“ language-plaintext Highlighter-rouge”串联的结果除外用户提供的新值。&lt;/p>; &lt;p>; &lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;的当前值只能通过使用与完全相同的相同的扩展来生成值的序列。如果我们甚至更改其中一个值，我们将为相同的&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;。&lt;/p>; &lt;p>;产生截然不同的最终结果功能用于称为&lt;a href=&quot;https://en.opensuse.org/portal：microos/remoteattestation#measured_boot&quot;>;“测量启动” &lt;/a>;的过程中的每个阶段，在启动链中测量了每个阶段在执行之前。这意味着在固件的初始阶段运行之前，有一个过程可以计算内存中的代码哈希，并扩展&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code &lt;/code >;使用此值。重复此操作直到引导序列的结尾：内核和&lt;code class =“ language-plaintext Highlighter-rouge”>; initrd &lt;/code>;。第一个10 &lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; s的最终值将比仅在计算机使用固件的已知版本，boot Loader和kernel的情况下才能预测。以及相关的数据，例如证书，配置文件或内核参数。如果这些元素之一更改（例如，通过使用其他安全引导证书），它将生成&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;值与我们期望的值不同。&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; /p>; &lt;p>; &lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;芯片是非常有趣的设备，一组功能远远超出了测量的启动。如果您想了解更多信息，我建议我推荐资源，例如&lt;a href=&quot;https://developers.tpm.dev/&quot;>; this &lt;/a>;或&lt;a href =“ https://trustedcomputinggroup.org/resource/a----实用的指导到tpm-2-0/“>; this &lt;/a>;。&lt;/p>; &lt;h2 id =“ tpm2-for-fde”>; &lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>; for &lt;code class =“ language-plaintext Highlighter-rouge”>; fde &lt;/code>; &lt;/h2>; &lt;p>;无论如何，这里的要点是我们可以创建一个可以指导&lt;code的“策略” class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;仅当某些&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; s仅包含预期值时才能解密秘密。详细信息有些不同，但是现在让我们将此模型用作一个很好的第一个近似。&lt;/p>; &lt;p>;的想法是，我们可以使用某些&lt;code class =” language-plaintext Highlighter加密密码-rouge“>; pcr &lt;/code>;寄存器，因此&lt;code class =“ language-plaintext Highlighter-rouge”>; grub2 &lt;/code>;以后可以连接&lt;code class =“ language-plaintext Highlighter-rouge”>; luks2 &lt;/代码>;设备如果&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;可以恢复密码，以验证系统的健康状况。如果&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;未能解密它，则意味着某些&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;没有启动过程中的预期值和某个阶段发生了变化。在这种情况下，&lt;code class =“ language-plaintext Highlighter-rouge”>; grub2 &lt;/code>;将询问用户的密码继续加载内核和系统的其余部分。它将关于新状态的信任委派给用户。&lt;/p>; &lt;p>; &lt;code class =“ language-plaintext Highlighter-rouge”>; grub2 &lt;/code>;还提供了一种工具，可以在当前值的当前值下密封秘密&lt;code class =“语言 -  plaintext Highlighter-rouge”>; pcr &lt;/code>; s的子集。这很好，但也带来了几个问题。一个是，也许我们正在以一种我们知道&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; s值在下一个启动期间会更改的方式（例如，在第一个启动期间）安装，启动加载程序升级或固件更新）。在这种情况下，使用当前寄存器值密封密封密封密封是没有用的：我们需要能够预测新密码并使用这些假设值进行密封。&lt;/p>; &lt;p>;另一个问题更阴险，并将成为以后进行批判。预期值可能会经常变化，也不是唯一的。也许有一组有效的有效。我们可以选择从其他内核或其他快照启动。 &lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;使用已知的授权策略为此提供了解决方案。它们是制定可以改变的政策的一种方式，但通过签名验证。从本质上讲，我们创建了一个公共和一个私钥，然后创建多个&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;使用私钥签名的策略。现在&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;可以使用公共部件验证签名，并使用&lt;code class =“ language-plaintext highlighter-rouge”>; pcr &lt; /code>;存储在新策略中的值。&lt;/p>; &lt;p>;自2023年初以来，OpenSuse提供&lt;a href=&quot;https://github.com/okirch/pcr-oracle&quot;>; &lt;code class =“语言-plaintext Highlighter-Rouge“>; pcr-oracle &lt;/code>; &lt;/a>;工具来帮助预测&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; registers，并加密密钥在这些值下，使用&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;策略或授权策略。使用此工具，我们现在可以在一组&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; s值中密封一个秘密！&lt;/p>; &lt;p>; &lt;/p>; &lt;p>; “ https://en.opensuse.org/sdb:ercrypted_root_file_system&quot;>; opensuse wiki &lt;/a>;我们可以找到有关这些主题的更多文档，包括有关如何在我们的安装中使用它的说明。&lt;/p>; &lt;h2 id = “使用&lt;code class =” dangudy-plaintext Highlighter-rouge“>; systemd &lt;/code>; for Disk加密&lt;/h2>; &lt;p>; with &lt;code class =”语言 -  plaintext =“ language-plaintextextextext” Highlighter-Rouge“>; grub2 &lt;/code>; &lt;code class =“ language-plaintext Highlighter-rouge”>; fde &lt;/code>;正常工作，那么为什么要寻找其他东西？原因之一是非常明显的：此体系结构只能工作……好吧……只有当我们的OpenSuse &lt;code class =“使用语言 -  plaintext Highlighter-Rouge”>; grub2 &lt;/code>;版本时。它将不适用于其他引导加载器，例如&lt;code class =“ language-plaintext Highlighter-rouge”>; SystemD-boot &lt;/code>;。实际上，它将无法与&lt;code class =“ language-plaintext Highlighter-rouge”>; grub2 &lt;/code>;本身的上游版本一起使用。&lt;/p>; &lt;p>;，但有第二个原因：我们可以争论没有&lt;code class =“ language-plaintext Highlighter-rouge”>; grub2 &lt;/code>;没有完整测量的启动。如果启动装载机需要在&lt;/strong>;之前解锁设备&lt;strong>;，则可以加载内核，自然是&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; pcr &lt;/code>;策略将评估系统的健康无法在内核，命令行或&lt;code class =“语言 -  plaintext Highlighter-rouge”>; initrd &lt;/code>;上进行断言。这些将在打开的&lt;code class =“ language-plaintext Highlighter-rouge”>; luks2 &lt;/code>;设备之后加载。 “>; systemd-boot &lt;/code>;为我们提供了&lt;code class =“ language-plaintext Highlighter-rouge”>; fde &lt;/code>;的替代体系结构，该&lt;/code>;可以与遵循&lt;code class =“语言”的任何引导加载程序正常使用-plaintext Highlighter-Rouge“>; bls &lt;/code>;（请记住，有一个&lt;code class =“ language-plaintext Highlighter-rouge”>; grub2 &lt;/code>;以支持它的补丁>;先验&lt;/em>;），并提供了在解锁设备之前进行完整测量的启动证明的机会。&lt;/p>; &lt;p>;一个区别是内核和&lt;code class =“ langaging-plaintext highlighter- Rouge“>; initrd &lt;/code>;将放置在未加密的&lt;code class =“ language-plaintext Highlighter-rouge”>; esp &lt;/code>;中，并解锁&lt;code class =“ languagen-plaintext Highlighter-rouge” >; SYSRoot &lt;/code>;将使用&lt;code class =“ language-plaintext Highlighter-rouge”>; initrd &lt;/code>;使用&lt;code class =“ language-plaintext highlighter-rouge”>; systemd-- CryptSetup &lt;/code>;提供。当前，它可以使用普通密码解锁设备，a &lt;code class =“ Language-Plaintext Highlighter-Rouge”>; tpm2 &lt;/code>;使用授权策略（可选的是用户必须输入的PIN）或a &lt;code class =“ language-plaintext Highlighter-Rouge”>; fido2 &lt;/code>;键设备。在&lt;code class =“ language-plaintext Highlighter-rouge”>;/etc/crypttab &lt;/code>;文件中，我们需要&lt;a href =“ https://www.freedesktop.org/software/software/software/systemdware/systemd/systemd/man/man/latest/ crypttab.html“>;描述&lt;/a>;解锁机制。&lt;/p>; &lt;p>; &lt;code class =“ language-plaintext Highlighter-rouge”>; pcr-oracle &lt;/code>;已扩展以支持授权的创建&lt;code class =“语言 -  plaintext Highlighter-rouge”>; SystemD &lt;/code>;可以理解的策略。它们存储在&lt;code class =“ language-plaintext Highlighter-rouge”>; json &lt;/code>;文件中，其中包含多个预测，每个文件都指示&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt; /code>; s，&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;策略哈希，公共密钥的指纹和策略的签名。这与公共密钥&lt;code class =“ language-plaintext Highlighter-rouge”>; pem &lt;/code>;文件，构成了&lt;code class =“ language-plaintext Highlighter-rouge”>; systemd-cryptsetup &lt;&lt;code class =“ /code>;用于使用&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>; &lt;/code>; &lt;code class =“ language-plaintext Highlighter-rouge”>; luks2 &lt;/code>; key。 /p>; &lt;p>; &lt;code class =“ language-plaintext Highlighter-rouge”>; rsa &lt;/code>; 2048用于签署策略的密钥可以使用&lt;code class =“ language-plaintext Highlighter-rouge”>; openssl &lt;/code>;或&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr-oracle &lt;/code>;本身。注意：如果私钥被泄漏，这是一款游戏，可以预期的安全性，即&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;可以提供。幸运的是，在这种情况下，该解决方案很便宜：生成一个新密钥，在&lt;code class =“ landing-plaintext Highlighter-rouge”中重新注册键Highlighter-Rouge”>; SystemD-Cryptenroll &lt;/code>;并使用&lt;code class =“ language-plaintext Highlighter-rouge”>; sdbootutil &lt;/code>;以重新生成每个启动条目的预测。是的……我们将在&lt;a href=&quot;https://en.opensuse.org/systemd-fde&quot;>;“ Systemd-fde” Wiki页面&lt;/a>;中记录所有过程。确实是一个便宜的操作。&lt;/p>; &lt;p>; OpenSuse正在提供&lt;a href=&quot;https://build.opensuse.org/package/package/show/devel:microos：microos：microos：images/opensuse-microos! &lt;/a>;名为&lt;a href=&quot;http://download.opensuse.org/tumbleweed/appliances/opensuse-microos.x86_64-kvm-kvm-and-xen-sdboot.qcow2&quot;>; a>;显示了所有这些工作的工作。此图像包含一些已经提到的工具集成的工具和其他一些新工具：&lt;/p>; &lt;ul>; &lt;li>; &lt;code class =“ language-plaintext Highlighter-rouge”>; systemd-boot &lt;/code>;：使用的启动加载程序已使用而不是默认&lt;code class =“ language-plaintext Highlighter-rouge”>; grub2 &lt;/code>; &lt;/li>; &lt;li>; &lt;li>; &lt;code class =“ language-plaintext Highlighter-rouge”>; sdbootutil &lt;/code>;：helper scripts要同步系统的引导条目&lt;/li>; &lt;li>; &lt;code class =“ language-plaintext Highlighter-rouge”>; pcr-oracle &lt;/code>;：预测&lt;code class =“ language-plaintext highlighter-rouge” >; pcr &lt;/code>; s下一个启动的值，并为&lt;code class =“ language-plaintext Highlighter-rouge”创建授权的策略”>; systemd &lt;/code>; &lt;/code>; &lt;/li>; &lt;li>; &lt;li>; &lt;code class =“语言” -plaintext Highlighter-Rouge“>; disk-compryption-tool &lt;/code>;：加密&lt;code class =“ language-plaintext Highlighter-rouge”>; sysroot &lt;/code>;位于第一个启动&lt;/li>; &lt;/li>; &lt;/li>; &lt;/code &lt;/code &lt;/code &lt;/code &lt;/code &lt;/code &lt;/code &lt;/code li>; &lt;code class =“ language-plaintext Highlighter-rouge”>; dracut-pcr-signature &lt;/code>;：&lt;code class =“ language-plaintext highlighter-rouge”>; dracut &lt;/code>; dracut &lt;/code>;模块，将预测加载到&lt;code class =“ language-plaintext Highlighter-rouge”>; intrd &lt;/code>;来自&lt;code class =“ language-plaintext Highlighter-rouge”>; esp &lt;/code>; &lt;/code>; &lt;/li>; &lt;/li>; &lt;/ul>; &lt;p>; &lt;p>;这些工具旨在为此新的&lt;code class =“ language-plaintext Highlighter-rouge”>; fde &lt;/code>;架构一起工作。接下来是关于如何连接的简要说明。&lt;/p>; &lt;p>;一旦我们获得了新的microos &lt;code class =“ language-plaintext Highlighter-rouge”>; qcow2 &lt;/code>; image，我们设置了VM，我们可以继续启动过程。如果VM具有虚拟&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;设备，它将开始测量执行的代码和数据，扩展相应的&lt;code class =“ Lanaging-Plaintext Highlighter-Rouge” >; pcr &lt;/code>; s。一旦达到了&lt;code class =“ language-plaintext Highlighter-rouge”>; Systemd-boot &lt;/code &lt;/code>;，它将找到此会话的正确启动条目，并将读取相应的内核和&lt;code class =“ languaging-plaintext Highlighter-Rouge“>; Initrd &lt;/code>;从中。&lt;/p>; &lt;p>;此时未加密图像。在第一个启动期间使用的&lt;code class =“ language-plaintext Highlighter-rouge”>; initrd &lt;/code>;，&lt;code class =“ language-plaintext Highlighter-rouge”>; disk-contryption-tool &lt;/code &lt;/code &lt;/code &lt;/code >;脚本将被调用。使用一些启发式方法，它将找到属于&lt;code class =“ language-plaintext Highlighter-rouge”>; sysroot &lt;/code>;（系统所在的位置）的分区，并将其调整大小以保留32MB的&lt;code class = &lt;code class = “语言 -  plaintext Highlighter-Rouge”>; luks2 &lt;/code>;标题。之后，它将使用&lt;code class =“ language-plaintext Highlighter-rouge”>; cryptsetup &lt;/code>;提供的所有魔术，以使用本地生成的密码重新加入设备。截至目前，此密码对应于将在结尾显示给用户的恢复密钥，并且用户应注意并确保其安全。&lt;/p>; &lt;p>;重新加入后，系统&lt;code &lt;code &lt;/p>; &lt;p>; class =“语言 -  plaintext Highlighter-rouge”>;/etc/crypttab &lt;/code>;将更新以通信，以确保该设备现在已加密，并应稍后使用不同的工具进行管理。&lt;/p>; &lt;p>; &lt;/p>; &lt;p>; &lt;code class =“ language-plaintext Highlighter-rouge”>; initrd &lt;/code>;我们切换到新的&lt;code class =“ language-plaintext Highlighter-rouge”>; sysroot &lt;/code &lt;/code>;，现在最终位于加密设备中。 &lt;code class =“ language-plaintext Highlighter-rouge”>;磁盘加密工具&lt;/code>;脚本已经完成了主要作业，但是它为&lt;code class =“ language-plaintext highlighter-rouge”安装了两个模块-firstboot &lt;/code>;，将在系统的第一个引导中执行，该系统正在发生！&lt;/p>; &lt;p>;第一个模块，&lt;code class =“ language-plaintext Highlighter-rouge”>; enroll &lt; /code>;，将检测是否存在&lt;code class =“ language-plaintext Highlighter-rouge”>; fido2 &lt;/code>;键插入键，并且&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;可用的。如果是这样，它将提出一个对话框，询问您要使用什么来解锁系统。第二个模块将询问用户是否&lt;code class =“ language-plaintext Highlighter-rouge”>; root &lt;/code>;密码也将在&lt;code class =“ language-plaintext Highlighter-rouge”>; luks2 &lt;/代码>;标题为新密钥，并将显示早期生成的恢复密钥。&lt;/p>; &lt;p>;截至今天，建议两者都不适合注册。如前所述，&lt;code class =“语言 -  plaintext Highlighter-rouge”>; fido2 &lt;/code>;键，如果我们使用笔记本电脑或台式机机器，我们希望使用标记证明的加密设备解锁加密设备我们拥有的。这是一个互动过程。 &lt;code class =“语言 -  plaintext Highlighter-rouge”>; tpm2 &lt;/code>;在我们不想与系统交互的情况下更有意义，并且只有在我们可以断言健康状况的情况下，我们才希望自动解锁设备系统（启动链中没有篡改）。&lt;/p>; &lt;p>;如果我们注册&lt;code class =“ language-plaintext Highlighter-rouge”>; fido2 &lt;/code>;键，&lt;code class =“语言” -plaintext Highlighter-Rouge“>; SystemD-Cryptenroll &lt;/code>;将被调用，我们将被要求两次按下按钮，并且安装过程将结束。在下一个启动时，我们将需要显示密钥，如果丢失了密钥，将询问恢复密码。&lt;/p>; &lt;p>;如果我们注册&lt;code class =“ language-plaintext Highlighter-rouge” >; tpm2 &lt;/code>;设备，一个新的&lt;code class =“ language-plaintext Highlighter-rouge”>; rsa &lt;/code>; 2048键在&lt;code class中生成和存储（公共和私有零件） Highlighter-Rouge”>;/etc/systemd &lt;/code>;和&lt;code class =“ language-plaintext Highlighter-rouge”>; Systemd-cryptenroll &lt;/code>;将用于注册公钥并注释&lt;code class =在密封&lt;code class =“ language-plaintext Highlighter-rouge”>; luks2 &lt;/code>;键中使用的“语言 -  plaintext Highlighter-rouge”>; PCR &lt;/code>; s。默认情况下，我们将使用0、2、4、7和9。一个>;。 &lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; s 0和2将测量所有&lt;code class =“ language-plaintext Highlighter-rouge”>; uefi &lt;/code &lt;/code>;固件代码。在也是UEFI二进制文件）。 &lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; 7将注册所有安全的引导证书，&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; 9将被使用由内核测量命令行，&lt;code class =“ language-plaintext Highlighter-rouge”>; initrd &lt;/code>;。&lt;/p>; &lt;p>;这几乎涵盖了所有可能有意义的对测量方法有最后一个词的用户。原因是预测是在&lt;code class =“ language-plaintext Highlighter-rouge”>; sdbootutil &lt;/code>;内完成的，请记住，该系统将在系统中每次更改后自动执行（更新，包装删除，快照管理，快照管理，等），此工具将仅对&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;在&lt;code class =“ landagy-plaintext Highlighter-rouge”中注册的预测代码>;标题。&lt;/p>; &lt;p>;不管选定的解锁机制如何，&lt;code class =“ language-plaintext highlighter-rouge”>;/etc/crypttab &lt;/code>;文件将使用此选择和新的选择更新&lt;code class =“ language-plaintext Highlighter-rouge”>;将生成Initrd &lt;/code>;以包含下一个启动的此信息。&lt;/p>; &lt;p>;最后，最后一个组件，&lt;code class =&#39;language-class-色解锁将在&lt;code class =“语言 -  plaintext Highlighter-rouge”>; initrd &lt;/code>;中存在“即时”。应该注意的是，&lt;code class =“ language-plaintext Highlighter-rouge”>; initrd &lt;/code>;将需要带有策略和密钥的JSON文件，但是这些文件不能包含在&lt;code class =“ language-class-”中。明文荧光笔 - >; initrd &lt;/code>;！当我们对&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;进行预测的那一刻，该>; pcr &lt;/code>;随着&lt;code class =“ language-plaintext Highlighter-rouge”>; initrd &lt; /code>;，仅此而言，我们无法再触摸&lt;code class =“ language-plaintext Highlighter-rouge”>; initrd &lt;/code>;，因为这将产生新的哈希，并且会自动将预测无效。&lt;/p>; &lt;p>;此&lt;code class =“ language-plaintext Highlighter-rouge”>; dracut &lt;/code>;模块将在&lt;code class =“ language-plaintext Highlighter-rouge”>; systemd-cryptsetup &lt;/code &lt;/code>; for for Generator &lt;/code class =“任何加密的设备都已经启动，并将在&lt;code class =“ language-plaintext Highlighter-rouge”>; ESP &lt;/code>; &lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2-pm2-pcr-signature的分区.json &lt;/code>;文件，其中包含当前启动的所有有效预测。此文件到位后，&lt;code class =“ language-plaintext Highlighter-rouge”>; systemd-crypsetup &lt;/code>;将能够在当前状态下断言设备是预期的，并且启动过程可以继续直到直到直到结尾。&lt;/p>; &lt;h2 id =“未来”>;未来&lt;/h2>; &lt;p>;图像在这里，是一个声音POC。它提供了更简单的体系结构，并将某些组件放在正确的位置。这将在下一阶段有很多帮助，因为我们还想处理与&lt;code class =“ language-plaintext Highlighter-rouge”>; fde &lt;/code>;。&lt;/p>;的其他一些事情。 &lt;p>;一个非常清晰的&lt;code class =“ language-plaintext Highlighter-rouge”>;磁盘加密工具&lt;/code>;具有有限的基于图像的安装。该代码的一部分应生活在&lt;code class =“ language-plaintext Highlighter-rouge”>; yast &lt;/code>;和&lt;code class =“ language-plaintext Highlighter-rouge”>; Agama &lt;/code>;中。安装程序已经在创建&lt;code class =“ language-plaintext Highlighter-rouge”>; luks2 &lt;/code>;设备，因此以对我们有用的方式扩展它应该“容易”。&lt;/p>; &lt;p>;理想情况下，&lt;code class =“ language-plaintext Highlighter-rouge”>; jeos-firstboot &lt;/code>;模块也应该生活在安装程序中，但是在这里它们也有意义。在任何情况下，都不应分开功能，并且都应合并。&lt;/p>; &lt;p>;加密工具从一开始就做某事：主密钥以及所有用户键在安装时间内生成，但一种可能的改进是在稍后使用&lt;code class =“ language-plaintext Highlighter-rouge”>; Systemd &lt;/code>;工具生成恢复密钥。这是一个小细节，但是将系统键与用户键分开可以简化架构。&lt;/p>; &lt;p>;改进的另一个方面是用户可能想要使用&lt;code class =“ language-plaintext Highlighter-rouge” >; tpm2 &lt;/code>;和&lt;code class =“ language-plaintext Highlighter-rouge”>; fido2 &lt;/code>;同时。例如，默认情况下，使用&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;，并且如果阶段以失败的预测方式更改（或者存在已检测到的安全漏洞），用户可以将解锁委托给&lt;code class =“ language-plaintext Highlighter-rouge”>; fido2 &lt;/code>;键，而不是使用密码。&lt;/p>; &lt;p>; &lt;code class =“语言” -plaintext Highlighter-Rouge“>; sdbootutil &lt;/code>;脚本包含一堆功能，这些功能也应生活在&lt;code class =“ language-plaintext Highlighter-rouge”>; systemd &lt;/code>; &lt;/code>;。与上游合作将使此工具随着时间的推移而过时，这将是更多的消息。&lt;/p>; &lt;p>;我们可以在&lt;code class =“ language-plaintext Highlighter-rouge”中提供帮助的另一个改进。 >;是为了提高诊断的原因，使&lt;code class =“ language-plaintext Highlighter-rouge”>; tpm2 &lt;/code>;拒绝&lt;code class =“ language-plaintext Highlighter-rouge”>; luks2 &lt;/代码>;键。今天，我们有一条通用的失败消息，而无需报告什么&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;或&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code class =“ lategan-plaintext Highlighter-rouge”>; pcr代码>;报告的哈希与预期的哈希相关。这将有助于低估出什么问题。引导加载程序是否更改？或固件中的东西？&lt;/p>; &lt;p>; &lt;code class =“ language-plaintext Highlighter-rouge”>; pcr-oracle &lt;/code>;是预测下一个&lt;code class =“语言 -  plaintext）的好工具Highlighter-Rouge“>; pcr &lt;/code>;值。很容易扩展到与完整测量的启动过程相关的日志中的新事件，包括内核，&lt;code class =“ language-plaintext Highlighter-rouge”>; systemd-boot &lt;/code &lt;/code &lt;/code>; extensions on &lt;code on &lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; 12，或生成&lt;code class =“ language-plaintext Highlighter-rouge”>; json &lt;/code>; &lt;/code>; &lt;code class =“ language-plaintextextext” Highlighter-Rouge“>; SystemD &lt;/code>;。新的&lt;code class =“ language-plaintext Highlighter-rouge”>; SystemD &lt;/code>; 255（一周前从撰写本文开始）包含一个名为&lt;code class =“ language-plaintext Highlighter-rouge”的类似工具>; SystemD-Pcrlock &lt;/code>;可以帮助我们提供所需的改进诊断。评估此工具进行预测也将很快完成。&lt;/p>; &lt;p>;今天类型1和类型＃2条目从&lt;code class =“ language-plaintext Highlighter-rouge”>; bls &lt;/code &lt;/code>;不是同构。 &lt;code class =“ language-plaintext Highlighter-rouge”>; efi &lt;/code>; &lt;code class =“ language-plaintext Highlighter-rouge”>; uki &lt;/code>;格式不存在文本表示。也许我们会决定在将来使用&lt;code class =“语言 -  plaintext Highlighter-rouge”>; uki &lt;/code>; s，或者也许不是。因此，一个良好的进步是致力于协助此统一，这将（除其他方面）提供了一种标准方法，可以将&lt;code class =“语言 -  plaintext Highlighter-rouge”>; json &lt;/code &lt;/code>;文件和将预测关联到每个引导加载程序条目。&lt;/p>; &lt;p>;生成和注册新键，或选择其他集合&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>; s今天是手动过程。可以扩展当前工具以在这些过程中提供帮助，也可以提供更好的文档。&lt;/p>; &lt;p>; &lt;code class =“ language-plaintext Highlighter-rouge”的新方法&lt;/code &lt;/code>;不是关于从等式中排除&lt;code class =“ language-plaintext Highlighter-rouge”>; grub2 &lt;/code>;。这是为了提供遵循&lt;code class =“ language-plaintext Highlighter-rouge”>; bls &lt;/code>;的不同引导加载程序的机会。验证适当的修补（duh！）&lt;code class =“ language-plaintext Highlighter-rouge”>; grub2 &lt;/code>;可以与所有这些合作。&lt;/p>; &lt;p>;，另一件事需要验证和改进的是具有多个加密磁盘的安装。原则上，设计和代码支持它（即使&lt;code class =“语言 -  plaintext Highlighter-rouge”>; pcr &lt;/code>;寄存器每卷都不同）。 &lt;code class =“ language-plaintext Highlighter-rouge”>; OpenQA &lt;/code>;将在这里创造奇迹。&lt;/p>; &lt;p>;，最后，如果&lt;code class =“ langaga-plaintext Highlighter-rouge”，我们应该重新考虑>; uki &lt;/code>; s对于不管是否有意义。如果我们朝那个方向迈进，则用于签署策略的专用密钥将保留在&lt;code class =“ language-plaintext Highlighter-rouge”>; obs &lt;/code &lt;/code>;中，并且这些策略也将在构建服务中生成一组不同的&lt;code class =“ language-plaintext Highlighter-rouge”>; pcr &lt;/code>;值。&lt;/p>; &lt;p>;无论如何，我们前面还有很多工作。&lt;/p>;</content:encoded></item></channel></rss>